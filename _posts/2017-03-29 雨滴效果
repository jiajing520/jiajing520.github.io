---
layout: post
title: 利用canvas实现雨滴效果
date: 2017-03-29
categories: blog
tags: 
description: 利用canvas标签和原生js实现雨滴效果

---
 
下面是代码

        <!doctype html>
        <html lang="en">
         <head>
          <meta charset="UTF-8">
          <meta name="Generator" content="EditPlus®">
          <meta name="Author" content="">
          <meta name="Keywords" content="">
          <meta name="Description" content="">
          <title>雨滴效果</title>
          <style>
          *{margin:0;padding:0;}
          html,body{height:100%;}
          canvas{
            width:100%;
            height:100%;
            background:#000;
            display:block;
          }
          </style>
         </head>
         <body>
          <canvas id="canvas">您的浏览器版本过低，请升级浏览器！</canvas>
          <script type="text/javascript">
            var can = document.getElementById("canvas");
            var cxt = can.getContext("2d");//设置绘图环境
            var w = can.width = window.innerWidth;
            var h = can.height = window.innerHeight;
            //让画布的宽高随浏览器窗口的变化而变化
            window.onresize = function(){
              w = can.width = window.innerWidth;
              h = can.height = window.innerHeight;
            }

            //面向对象
            var drops = [];
            //创建雨滴对象
            function Drop(){}
            //添加对象方法
            Drop.prototype = {
              init : function(){//初始化方法（设置每个雨滴的初始属性）
                this.x = random(0,w);
                this.y = 0;
                //y方向的速度值
                this.vy = random(4,5);
                //雨滴下落的最大高度
                this.l = random(0.8*h,0.9*h);
                //波纹的半径
                this.r = 1;
                this.vr = 1;//半径增大的速度
                //判断雨滴消失的不透明度
                this.a = 1;
                this.va = 0.96;//透明度的变化系数
              },
              draw : function(){//绘制图形
                if(this.y > this.l){//雨滴下落到指定位置   开始绘制圆形
                  cxt.beginPath();//先开始路径
                  cxt.arc(this.x,this.y,this.r,0,Math.PI*2,false);
                  cxt.strokeStyle = "rgba(0,255,255,"+this.a+")";
                  cxt.stroke();
                }else{//绘制下落的雨滴
                  cxt.fillStyle = "rgb(0,255,255)";
                  cxt.fillRect(this.x,this.y,2,10);
                }
                this.update();
              },
              update : function(){//更新坐标位置
                if(this.y < this.l)
                {
                  this.y += this.vy;
                }else{//雨滴下落到指定位置  开始绘制波纹
                  if(this.a > 0.03){
                    this.r += this.vr;
                    if(this.r > 50){
                      this.a *= this.va;
                    }
                  }else{
                    //重新初始化雨滴数据
                    this.init();
                  }
                }
              }
            }

            for(var i=0;i<30;i++){
              setTimeout(function(){
                var drop = new Drop();
                drop.init();
                drops.push(drop);
              },i*300)	
            }

            function move(){
              cxt.fillStyle = "rgba(0,0,0,0.1)";
              cxt.fillRect(0,0,w,h);
              for(var i=0;i<drops.length;i++){
                drops[i].draw();
              }
              requestAnimationFrame(move);//原生js的经动画
            }
            move();

            //生成随机数
            function random(min,max){
              return Math.random()*(max-min) + min;//min-max之间的随机数
            }
          </script>
         </body>
        </html>
